<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
<title>Tumbang Preso Game üéØ</title>
<style>
  :root{
    --bg:#0f1221; --fg:#eaf4ff; --muted:#92a1b3;
    --accent:#ffd166; --accent2:#06d6a0; --danger:#ff4d6d; --it:#7b5cff; --can:#c0c7d1;
  }
  html,body{height:100%;margin:0;background:radial-gradient(1200px 700px at 70% -10%, #1b2250 0%, #0f1221 60%) fixed;color:var(--fg);font-family:system-ui,Segoe UI,Roboto,Inter,Arial,sans-serif;}
  .wrap{display:flex;flex-direction:column;gap:.5rem;align-items:center;justify-content:flex-start;min-height:100%;}
  h1{font-size:clamp(18px,2.6vw,28px);letter-spacing:.4px;margin:14px 0 4px}
  .hud{display:flex;gap:12px;flex-wrap:wrap;align-items:center;justify-content:center}
  .badge{background:#1a1f3b;border:1px solid #232a52;color:var(--fg);padding:6px 10px;border-radius:999px;font-weight:600;box-shadow:0 0 0 1px #0b0f26 inset}
  .btn{background:linear-gradient(180deg,#232a52,#14183a);border:1px solid #2a3270;color:#fff;padding:8px 12px;border-radius:12px;cursor:pointer;font-weight:700}
  .btn:hover{filter:brightness(1.1)}
  canvas{touch-action:none;background:
    linear-gradient(#0e142e 0 0) padding-box,
    linear-gradient(180deg,transparent 70%,rgba(255,255,255,.06)) border-box;
    border:2px solid transparent;border-radius:16px;box-shadow:0 10px 40px rgba(0,0,0,.45);max-width:100%;height:auto}
  .tip{font-size:12px;color:var(--muted);opacity:.95}
  .overlay{position:fixed;inset:0;background:rgba(5,7,16,.72);display:none;align-items:center;justify-content:center;padding:20px;z-index:10;}
  .card{width:min(680px,92vw);background:#121736;border:1px solid #263079;border-radius:16px;padding:18px 18px 12px;line-height:1.5;box-shadow:0 20px 80px rgba(0,0,0,.6)}
  .card h2{margin:.2rem 0 0;font-size:22px}
  .list{margin:.2rem 0 .8rem;padding-left:18px}
  .kbd{background:#0e1330;border:1px solid #23306b;border-radius:8px;padding:4px 8px;font-weight:700}
</style>
</head>
<body>
<div class="wrap">
  <h1>ü©¥ Tumbang Preso Game </h1>
  <div class="hud">
    <div class="badge" id="score">Score: 0</div>
    <div class="badge" id="round">Round: 1</div>
    <div class="badge" id="status">Status: Aim & Flick</div>
    <button class="btn" id="btnHelp">How to Play</button>
    <button class="btn" id="btnRestart">Restart</button>
    <p style="color: blue;font-family: cursive;">Created by: Mark Angelo Lasala</p>
  </div>
  <canvas id="game" width="960" height="560" aria-label="Tumbang Preso street"></canvas>
  <div class="tip">Drag from the player (left) to aim ‚Äî release to flick. After throwing, drag your player to retrieve the slipper and run back to the <b>crosswalk Safe Zone</b>. Avoid the <b style="color:var(--it)">‚Äúit‚Äù</b>!</div>
</div>

<!-- Overlays -->
<div class="overlay" id="help">
  <div class="card">
    <h2>How to Play</h2>
    <ul class="list">
      <li><b>Aim & Flick:</b> Press/drag from your player (left circle) ‚Äî the longer the drag, the stronger the throw. Release to throw the slipper.</li>
      <li><b>Topple the Can:</b> Hit the sardine can stack near center to score and advance the round.</li>
      <li><b>Retrieve Safely:</b> After your throw, drag your player to pick up the slipper and get back to the <b>crosswalk Safe Zone</b> without being tagged by the <span style="color:var(--it)">‚Äúit‚Äù</span>.</li>
      <li><b>Power-Ups:</b> Random orbs appear:
        <ul>
          <li><span style="color:var(--accent2);font-weight:700">Double Slipper</span> ‚Äî next throw launches 2 slippers.</li>
          <li><span style="color:var(--accent);font-weight:700">Wind Boost</span> ‚Äî next throw is faster with a gust.</li>
        </ul>
      </li>
    </ul>
    <p><span class="kbd">Restart</span> anytime to try different strategies.</p>
    <button class="btn" id="btnCloseHelp">Let‚Äôs Play!</button>
  </div>
</div>

<div class="overlay" id="gameover">
  <div class="card" style="text-align:center">
    <h2>üö´ Tagged! Game Over</h2>
    <p id="finalStats">You scored 0 points.</p>
    <button class="btn" id="btnAgain">Play Again</button>
  </div>
</div>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const W = () => canvas.width, H = () => canvas.height;

  // --- GAME CONSTANTS MOVED UP (fixes blank screen) ---
  const SAFE_X = 140;
  const FRICTION = 0.990;
  const ROT_DRAG = 0.995;
  const SLIP_R = 12;
  const PLAYER_R = 16;
  const IT_R = 16;
  const PICKUP_DIST = SLIP_R + PLAYER_R + 2;
  const TAG_DIST = PLAYER_R + IT_R + 2;
  const BASE_STACK = 1;

  // Assets
  const IMG_SLIPPER = 'slipper.png';
  const IMG_SARDINE = 'sardine.png';
  const SLIPPER_SCALE = 0.18;
  const CAN_SCALE = 0.13;

  const assets = {
    slipper: new Image(),
    can: new Image(),
    ready: { slipper:false, can:false }
  };

  let CAN_W = 26, CAN_H = 44;
  assets.slipper.onload = ()=> assets.ready.slipper = true;
  assets.can.onload = ()=> {
    assets.ready.can = true;
    CAN_W = assets.can.width  * CAN_SCALE;
    CAN_H = assets.can.height * CAN_SCALE;
    buildStreetBG();
  };
  assets.slipper.src = IMG_SLIPPER;
  assets.can.src = IMG_SARDINE;

  // Utils
  const clamp = (v,min,max)=>Math.max(min,Math.min(max,v));
  const dist2 = (a,b)=>{const dx=a.x-b.x, dy=a.y-b.y; return dx*dx+dy*dy;};
  const rnd = (a,b)=>Math.random()*(b-a)+a;

  function circleRectCollide(cx, cy, cr, rx, ry, rw, rh){
    const nx = clamp(cx, rx, rx+rw);
    const ny = clamp(cy, ry, ry+rh);
    const dx = cx - nx, dy = cy - ny;
    return (dx*dx + dy*dy) <= cr*cr;
  }

  // ‚Äî‚Äî Street background (cached) ‚Äî‚Äî
  let streetBG = null;
function buildStreetBG(){
    const w = W(), h = H();
    streetBG = document.createElement('canvas');
    streetBG.width = w; streetBG.height = h;
    const g = streetBG.getContext('2d');

    // --- Sky ---
    const sky = g.createLinearGradient(0,0,0,h*0.45);
    sky.addColorStop(0,'#0d1434');
    sky.addColorStop(1,'#121a3f');
    g.fillStyle = sky;
    g.fillRect(0,0,w,h*0.45);

    // üåû Add Sun above the street
    const sunX = w * 0.8;   // position near top-right
    const sunY = h * 0.12;
    const sunR = 40;

    // Sun glow
    const sunGradient = g.createRadialGradient(sunX, sunY, sunR*0.1, sunX, sunY, sunR*2);
    sunGradient.addColorStop(0, 'rgba(255, 223, 100, 1)');
    sunGradient.addColorStop(1, 'rgba(255, 223, 100, 0)');
    g.fillStyle = sunGradient;
    g.beginPath();
    g.arc(sunX, sunY, sunR*2, 0, Math.PI*2);
    g.fill();

    // Sun core
    g.fillStyle = '#ffdf64';
    g.beginPath();
    g.arc(sunX, sunY, sunR, 0, Math.PI*2);
    g.fill();

    // --- Buildings ---
    function buildings(yBase, height, count, color){
        for(let i=0;i<count;i++){
            const bw = rnd(40,120);
            const bh = rnd(height*0.4,height);
            const x = rnd(-30,w+30);
            g.fillStyle = color;
            g.fillRect(x, yBase - bh, bw, bh);
            g.globalAlpha = 0.15;
            for(let k=0;k<Math.floor(bw/20);k++){
                const wx = x + 6 + k*16;
                for(let r=0;r<Math.floor(bh/24);r++){
                    if (Math.random()<0.22){
                        g.fillStyle = '#ffd166';
                        g.fillRect(wx, yBase - bh + 6 + r*18, 6, 8);
                    }
                }
            }
            g.globalAlpha = 1;
        }
    }
    buildings(h*0.42, 140, 10, '#0c1330');
    buildings(h*0.45, 110, 12, '#0a1028');

    const roadTop = h*0.18;
    const roadBottom = h*0.92;
    g.fillStyle = '#1c1f2a';
    g.fillRect(0, roadTop, w, roadBottom-roadTop);

    g.globalAlpha = 0.08;
    g.fillStyle = '#ffffff';
    for(let i=0;i<600;i++){
      const x = Math.random()*w, y = roadTop + Math.random()*(roadBottom-roadTop);
      g.fillRect(x, y, 1, 1);
    }
    g.globalAlpha = 1;

    const sideH = 28;
    g.fillStyle = '#2a2f3d';
    g.fillRect(0, roadTop - sideH, w, sideH);
    g.fillRect(0, roadBottom, w, sideH);
    g.fillStyle = '#3a4253';
    g.fillRect(0, roadTop - 3, w, 3);
    g.fillRect(0, roadBottom, w, 3);

    g.strokeStyle = 'rgba(255,255,255,0.28)';
    g.lineWidth = 3;
    g.setLineDash([14,14]);
    g.beginPath();
    g.moveTo(0, (roadTop+roadBottom)/2);
    g.lineTo(w, (roadTop+roadBottom)/2);
    g.stroke();
    g.setLineDash([]);

    function manhole(x,y){
      g.fillStyle='rgba(0,0,0,0.35)';
      g.beginPath(); g.ellipse(x,y,18,8,0,0,Math.PI*2); g.fill();
      g.fillStyle='#303647';
      g.beginPath(); g.arc(x,y,10,0,Math.PI*2); g.fill();
      g.strokeStyle='#212532'; g.lineWidth=2;
      g.beginPath(); g.arc(x,y,10,0,Math.PI*2); g.stroke();
    }
    manhole(w*0.32, (roadTop+roadBottom)/2 + 40);
    manhole(w*0.72, (roadTop+roadBottom)/2 - 36);

    g.strokeStyle='rgba(255,255,255,0.05)';
    g.lineWidth=1;
    g.beginPath();
    g.moveTo(w*0.55, roadTop+30); g.quadraticCurveTo(w*0.6, roadTop+60, w*0.65, roadTop+40); g.stroke();
    g.beginPath();
    g.moveTo(w*0.4, roadBottom-30); g.quadraticCurveTo(w*0.45, roadBottom-10, w*0.5, roadBottom-22); g.stroke();

    // Crosswalk (SAFE ZONE)
    const cwX = SAFE_X - 8;
    const barGap = 12, barW = 10;
    const cwTop = roadTop, cwBottom = roadBottom;
    g.globalAlpha = 0.9;
    g.fillStyle = 'rgba(255,255,255,0.85)';
    for(let y=cwTop+8; y<cwBottom-8; y+=barGap){
      g.fillRect(cwX, y, barW, 8);
      g.fillRect(cwX+26, y, barW, 8);
      g.fillRect(cwX+52, y, barW, 8);
      g.fillRect(cwX+78, y, barW, 8);
    }
    g.globalAlpha = 1;

    g.font = '700 13px system-ui,Segoe UI';
    g.fillStyle = 'rgba(255,255,255,0.75)';
    g.fillText('Safe Zone', 12, roadTop - 10);

    function lamp(x){
      g.fillStyle='#1a1e2b';
      g.fillRect(x-2, roadTop-28, 4, roadTop-54);
      g.fillStyle='#262c3e';
      g.fillRect(x-10, roadTop-54, 20, 6);
      g.fillStyle='rgba(255,230,160,0.15)';
      g.beginPath();
      g.moveTo(x, roadTop-48); g.lineTo(x-40, roadTop-10); g.lineTo(x+40, roadTop-10); g.closePath(); g.fill();
    }
    lamp(w*0.35);
    lamp(w*0.82);
  }

  // Responsive canvas scale
  const fit = () => {
    const maxW = Math.min(960, window.innerWidth - 24);
    const ratio = 960/560;
    canvas.width = 960;
    canvas.height = 560;
    canvas.style.width = maxW + 'px';
    canvas.style.height = (maxW/ratio) + 'px';
    buildStreetBG(); // safe now ‚Äî constants exist
  };
  fit(); addEventListener('resize', fit, {passive:true});

  // HUD
  const $score = document.getElementById('score');
  const $round = document.getElementById('round');
  const $status = document.getElementById('status');
  const $help = document.getElementById('help');
  const $gameover = document.getElementById('gameover');
  const $finalStats = document.getElementById('finalStats');
  document.getElementById('btnHelp').onclick = ()=> $help.style.display='flex';
  document.getElementById('btnCloseHelp').onclick = ()=> $help.style.display='none';
  document.getElementById('btnRestart').onclick = ()=> restart();
  document.getElementById('btnAgain').onclick = ()=> { $gameover.style.display='none'; restart(); };

  // State
  let state;
  function makeState(){
    const canX = 0.55*W(), canY = 0.54*H();
    return {
      running:true, score:0, round:1, phase:'aim',
      windActive:false, doubleActive:false,
      player:{x:SAFE_X*0.6, y:H()*0.7, vx:0, vy:0, walk:0, lastX:0, lastY:0},
      slippers:[],
      can:{ x:canX, y:canY, hp:BASE_STACK, fallen:false, tilt:0, wobble:0, wobbleDir:(Math.random()<0.5?-1:1), flash:0 },
      it:{
        x:canX + 120, y:canY, speed:1.5, mode:'patrol', t:0, walk:0, lastX:0, lastY:0,
        patrolA:{x:canX + 120, y:canY - 80},
        patrolB:{x:canX + 120, y:canY + 80}
      },
      powerups:[],
      fx:[],
      aim:{active:false, sx:0, sy:0, x:0, y:0},
      retrieveHasSlipper:false,
      statusMsg:'Aim & Flick',
      cooldown:0,
      draggingPlayer:false
    };
  }

  function spawnPowerUp(){
    if (Math.random()<0.4){
      const type = Math.random()<0.5 ? 'double' : 'wind';
      const x = rnd(SAFE_X+120, W()-80), y=rnd(120,H()-120);
      state.powerups.push({x,y,type,ttl:18_000});
    }
  }

  function resetRound(){
    const canX = 0.55*W(), canY = 0.54*H();
    state.can = { x:canX,y:canY,hp:BASE_STACK + Math.floor((state.round-1)/3), fallen:false, tilt:0, wobble:0, wobbleDir:(Math.random()<0.5?-1:1), flash:0 };
    state.it = {
      x:canX+120,y:canY,speed:1.5 + 0.15*(state.round-1),mode:'patrol',t:0, walk:0, lastX:canX+120, lastY:canY,
      patrolA:{x:canX+120,y:canY-80}, patrolB:{x:canX+120,y:canY+80}
    };
    state.slippers.length=0;
    state.retrieveHasSlipper=false;
    state.phase='aim';
    state.windActive=false;
    state.doubleActive=false;
    state.powerups = [];
    state.fx = [];
    spawnPowerUp();
    state.statusMsg = 'Aim & Flick';
  }

  // FX
  function spawnBurst(x,y,count,type='spark'){
    for(let i=0;i<count;i++){
      const ang = Math.random()*Math.PI*2;
      const spd = type==='spark' ? rnd(1.2,3.6) : rnd(0.5,1.6);
      const vx = Math.cos(ang)*spd, vy = Math.sin(ang)*spd;
      state.fx.push({
        x,y,vx,vy,
        life: type==='spark'? 500+Math.random()*300 : 700+Math.random()*500,
        t:0,
        r: type==='spark'? rnd(1.2,2.2) : rnd(2.5,4.0),
        color: type==='spark'? (Math.random()<0.5?'#ffd166':'#ffffff') : 'rgba(180,190,200,1)',
        grav: type==='spark'? 0.02 : -0.005,
        fadeCurve: type==='spark'?'linear':'ease'
      });
    }
  }
  function drawFX(dt){
    for (const p of state.fx){ p.t += dt; p.x += p.vx; p.y += p.vy; p.vy += p.grav; }
    for (const p of state.fx){
      const k = Math.min(1, p.t/p.life);
      let alpha = 1-k; if (p.fadeCurve==='ease') alpha = (1-k)*(1-k);
      ctx.globalAlpha = alpha;
      ctx.beginPath(); ctx.arc(p.x,p.y,p.r,0,Math.PI*2); ctx.fillStyle='#fff'; ctx.fill();
      ctx.globalAlpha = 1;
    }
    state.fx = state.fx.filter(p=>p.t < p.life);
  }

  // FIELD & OBJECTS
  function drawField(){
    if (streetBG) ctx.drawImage(streetBG, 0, 0);
    else { ctx.fillStyle='#1c1f2a'; ctx.fillRect(0,0,W(),H()); }
    ctx.strokeStyle='rgba(255,255,255,0.06)'; ctx.lineWidth=2;
    ctx.beginPath(); ctx.moveTo(SAFE_X,0); ctx.lineTo(SAFE_X,H()); ctx.stroke();
  }

  function drawHuman(x, y, options = {}){
    const { scale = 1, facing = 1, walk = 0, carry = false } = options;
    ctx.fillStyle='rgba(0,0,0,0.45)';
    ctx.beginPath(); ctx.ellipse(x, y+10*scale, 14*scale, 7*scale, 0, 0, Math.PI*2); ctx.fill();
    const step = Math.sin(walk)*8*scale;
    const armSwing = Math.sin(walk+Math.PI/2)*6*scale;
    ctx.save(); ctx.translate(x, y); ctx.scale(facing, 1);
    ctx.fillStyle = '#000'; ctx.strokeStyle = 'rgba(255,255,255,0.12)'; ctx.lineWidth = 1.2;
    ctx.beginPath(); ctx.arc(0, -16*scale, 6*scale, 0, Math.PI*2); ctx.fill(); ctx.stroke();
    const bw = 10*scale; ctx.beginPath();
    ctx.moveTo(-bw, -10*scale); ctx.lineTo(-bw, 6*scale);
    ctx.quadraticCurveTo(-bw, 9*scale, -bw+3*scale, 9*scale);
    ctx.lineTo(bw-3*scale, 9*scale); ctx.quadraticCurveTo(bw, 9*scale, bw, 6*scale);
    ctx.lineTo(bw, -10*scale); ctx.closePath(); ctx.fill(); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(0, -8*scale); ctx.lineTo(-10*scale, (-2 + armSwing)*scale); ctx.lineWidth = 3*scale; ctx.stroke();
    ctx.beginPath(); ctx.moveTo(0, -8*scale); ctx.lineTo(10*scale, (-2 - armSwing)*scale); ctx.lineWidth = 3*scale; ctx.stroke();
    ctx.lineWidth = 3.4*scale;
    ctx.beginPath(); ctx.moveTo(-4*scale, 9*scale); ctx.lineTo(-4*scale, (18 - step)*scale); ctx.lineTo(0, (18 - step)*scale); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(4*scale, 9*scale); ctx.lineTo(4*scale, (18 + step)*scale); ctx.lineTo(8*scale, (18 + step)*scale); ctx.stroke();
    if (carry){ ctx.fillStyle='#000'; ctx.beginPath(); ctx.arc(14*scale, -8*scale, 2.5*scale, 0, Math.PI*2); ctx.fill(); }
    ctx.restore();
  }

  function drawSlipper(s){
    ctx.save(); ctx.translate(s.x,s.y); ctx.rotate(s.rot||0);
    ctx.fillStyle='rgba(0,0,0,0.35)';
    ctx.beginPath(); ctx.ellipse(0, SLIP_R*0.9, SLIP_R*1.2, SLIP_R*0.5, 0, 0, Math.PI*2); ctx.fill();
    if (assets.ready.slipper){
      const w = assets.slipper.width * SLIPPER_SCALE;
      const h = assets.slipper.height * SLIPPER_SCALE;
      ctx.drawImage(assets.slipper, -w/2, -h/2, w, h);
    } else {
      ctx.fillStyle='#ff4d6d'; ctx.beginPath(); ctx.ellipse(0,0,SLIP_R*1.6,SLIP_R,0,0,Math.PI*2); ctx.fill();
    }
    ctx.restore();
  }

  function drawCan(){
    const c = state.can;
    const wobbleAmt = c.wobble>0 && !c.fallen ? Math.sin((Date.now()/80)) * (c.wobble/800) * 0.2 * c.wobbleDir : 0;
    const flashAlpha = c.flash>0 ? Math.min(0.35, c.flash/120*0.35) : 0;
    const spacing = CAN_H * 0.9;
    const baseRX = CAN_W * (0.40 + 0.18 * (c.hp - 1));
    const baseRY = CAN_W * (0.18 + 0.06 * (c.hp - 1));
    const tilt = c.fallen ? Math.abs(c.tilt) : Math.abs(wobbleAmt);
    const squash = 1 + Math.min(0.6, tilt * 0.9);
    ctx.save();
    ctx.translate(c.x, c.y + CAN_H/2 + 8 + (c.hp>1 ? 2 : 0));
    ctx.fillStyle = 'rgba(0,0,0,.38)';
    ctx.beginPath(); ctx.ellipse(0, 0, baseRX * squash, baseRY / squash, 0, 0, Math.PI*2); ctx.fill();
    ctx.restore();
    for(let i=0;i<c.hp;i++){
      const x = c.x, y = c.y - i*spacing;
      const thisTilt = c.fallen ? (c.tilt + i*0.07) : wobbleAmt;
      ctx.save(); ctx.translate(x,y); ctx.rotate(thisTilt);
      if (flashAlpha>0 && !c.fallen){
        ctx.fillStyle = `rgba(255,255,255,${flashAlpha})`;
        ctx.fillRect(-CAN_W/2-3, -CAN_H/2-3, CAN_W+6, CAN_H+6);
      }
      if (assets.ready.can){
        ctx.drawImage(assets.can, -CAN_W/2, -CAN_H/2, CAN_W, CAN_H);
      } else {
        ctx.fillStyle='var(--can)'; ctx.strokeStyle='#8e96a3'; ctx.lineWidth=2;
        ctx.beginPath(); ctx.roundRect(-CAN_W/2, -CAN_H/2, CAN_W, CAN_H, 8); ctx.fill(); ctx.stroke();
      }
      ctx.restore();
    }
  }

  function drawPowerups(){
    for(const pu of state.powerups){
      ctx.save(); ctx.translate(pu.x,pu.y);
      ctx.fillStyle= pu.type==='double' ? 'rgba(6,214,160,.15)' : 'rgba(255,209,102,.15)';
      ctx.beginPath(); ctx.arc(0,0,20,0,Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(0,0,10,0,Math.PI*2);
      ctx.fillStyle = pu.type==='double' ? 'var(--accent2)' : 'var(--accent)';
      ctx.fill(); ctx.lineWidth=2; ctx.strokeStyle='rgba(0,0,0,.35)'; ctx.stroke();
      ctx.fillStyle='#0b0d1e'; ctx.font='700 11px system-ui'; ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillText(pu.type==='double'?'√ó2':'üí®', 0, 0.5);
      ctx.restore();
    }
  }

  function drawAim(){
    const a = state.aim; if(!a.active) return;
    ctx.strokeStyle='rgba(255,255,255,.35)'; ctx.lineWidth=2;
    ctx.beginPath(); ctx.moveTo(a.sx,a.sy); ctx.lineTo(a.x,a.y); ctx.stroke();
    const dx=a.x-a.sx, dy=a.y-a.sy; const L = Math.min(100, Math.hypot(dx,dy));
    ctx.fillStyle='rgba(255,255,255,.3)';
    ctx.beginPath(); ctx.arc(a.sx,a.sy,4,0,Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(a.sx - dx/L*18, a.sy - dy/L*18, 6, 0, Math.PI*2); ctx.fill();
  }

  function drawUI(){
    let s = [];
    if (state.doubleActive) s.push('Double Slipper');
    if (state.windActive) s.push('Wind Boost');
    if (s.length){
      ctx.fillStyle='rgba(0,0,0,.25)'; ctx.fillRect(W()-250, 10, 240, 28);
      ctx.font='700 12px system-ui'; ctx.fillStyle='rgba(255,255,255,.8)';
      ctx.textAlign='right'; ctx.fillText(s.join(' ¬∑ '), W()-16, 28);
      ctx.textAlign='left';
    }
  }

  // Input
  let pointer = {down:false, x:0, y:0};
  function pointerPos(e){
    const r = canvas.getBoundingClientRect();
    if (e.touches && e.touches[0]){
      const t = e.touches[0];
      return { x:(t.clientX - r.left) * (canvas.width/r.width),
               y:(t.clientY - r.top) * (canvas.height/r.height) };
    } else {
      return { x:(e.clientX - r.left) * (canvas.width/r.width),
               y:(e.clientY - r.top) * (canvas.height/r.height) };
    }
  }
  function onDown(e){
    e.preventDefault();
    const {x,y} = pointerPos(e);
    pointer.down=true; pointer.x=x; pointer.y=y;
    if (state.phase==='aim'){
      const d2 = dist2({x,y}, state.player);
      if (d2 <= (PLAYER_R+22)*(PLAYER_R+22)){
        state.aim={active:true,sx:state.player.x,sy:state.player.y,x,y};
      }
    } else if (state.phase==='retrieve'){
      state.draggingPlayer = true;
    }
  }
  function onMove(e){
    if (!pointer.down) return;
    const {x,y} = pointerPos(e); pointer.x=x; pointer.y=y;
    if (state.phase==='aim' && state.aim.active){
      state.aim.x=x; state.aim.y=y;
    } else if (state.phase==='retrieve' && state.draggingPlayer){
      const p = state.player; const vx = x - p.x, vy = y - p.y;
      const L = Math.hypot(vx,vy) || 1; const speed = 4.0;
      p.x += vx/L * speed; p.y += vy/L * speed;
    }
  }
  function onUp(e){
    if (!pointer.down) return;
    pointer.down=false; state.draggingPlayer=false;
    if (state.phase==='aim' && state.aim.active){
      const a = state.aim; a.active=false;
      const dx = (a.x - a.sx), dy = (a.y - a.sy);
      let vx = -dx * 0.16, vy = -dy * 0.16;
      const speedMag = Math.hypot(vx,vy);
      if (speedMag <= 2.2) return;
      if (state.windActive){ vx = vx*1.25 + rnd(-1.2,1.2); vy = vy*1.25 + rnd(-0.6,0.6); }
      const baseOmega = (Math.random()<0.5?-1:1) * (0.04 + Math.min(0.18, speedMag*0.01));
      const launch = (offset=0, wobble=0)=>{
        state.slippers.push({
          x:state.player.x + offset, y:state.player.y,
          vx:vx + wobble, vy:vy + wobble*0.6,
          active:true, rot:0, omega: baseOmega + rnd(-0.02,0.02)
        });
      };
      if (state.doubleActive){ launch(-10, rnd(-0.5,0.5)); launch(10, rnd(-0.5,0.5)); } else launch(0, 0);
      state.windActive=false; state.doubleActive=false;
      state.phase='thrown'; state.statusMsg='Watch the shot!';
    }
  }
  canvas.addEventListener('mousedown',onDown); canvas.addEventListener('mousemove',onMove); addEventListener('mouseup',onUp);
  canvas.addEventListener('touchstart',onDown,{passive:false}); canvas.addEventListener('touchmove',onMove,{passive:false}); canvas.addEventListener('touchend',onUp,{passive:false});

  // Logic
  function update(dt){
    const p = state.player;
    p.x = clamp(p.x, PLAYER_R, W()-PLAYER_R);
    p.y = clamp(p.y, PLAYER_R, H()-PLAYER_R);

    const pvx = p.x - (p.lastX ?? p.x), pvy = p.y - (p.lastY ?? p.y);
    if (Math.hypot(pvx, pvy) > 0.1) p.walk += dt*0.015;
    p.lastX = p.x; p.lastY = p.y;

    for (const s of state.slippers){
      if (!s.active) continue;
      s.x += s.vx; s.y += s.vy;
      s.vx *= FRICTION; s.vy *= FRICTION;
      const vmag = Math.hypot(s.vx, s.vy);
      s.rot += s.omega * (0.6 + vmag/10);
      s.omega *= ROT_DRAG;
      if (s.x<SLIP_R || s.x>W()-SLIP_R){ s.vx*=-0.6; s.x=clamp(s.x,SLIP_R,W()-SLIP_R); s.omega *= -0.7; }
      if (s.y<SLIP_R || s.y>H()-SLIP_R){ s.vy*=-0.6; s.y=clamp(s.y,SLIP_R,H()-SLIP_R); s.omega *= -0.7; }
      if (Math.abs(s.vx)+Math.abs(s.vy) < 0.25) { s.vx=0; s.vy=0; s.active=false; }

      const c = state.can; if (!c.fallen){
        const spacing = CAN_H * 0.9;
        for (let i=0; i<c.hp; i++){
          const rx = c.x - CAN_W/2 - 2;
          const ry = (c.y - i*spacing) - CAN_H/2 - 2;
          const rw = CAN_W + 4;
          const rh = CAN_H + 4;
          if (circleRectCollide(s.x, s.y, SLIP_R, rx, ry, rw, rh)){
            const impact = Math.hypot(s.vx,s.vy);
            if (impact>3.2){
              c.wobble = Math.min(800, c.wobble + 450);
              c.flash = 120;
              c.wobbleDir = (s.x < c.x ? -1 : 1) * (Math.random()<0.5?-1:1);
              spawnBurst(s.x, s.y, 12, 'spark');
              c.hp = Math.max(0, c.hp-1);
              s.vx *= -0.35; s.vy *= -0.35; s.omega += (Math.random()<0.5?-1:1) * 0.12;
              if (c.hp===0){ c.fallen=true; c.tilt = rnd(-0.7,0.7); spawnBurst(c.x, c.y + CAN_H/2, 18, 'dust'); state.statusMsg='Can toppled! Retrieve safely.'; }
              break;
            }
          }
        }
      }
    }

    if (state.can.wobble>0) state.can.wobble = Math.max(0, state.can.wobble - dt);
    if (state.can.flash>0) state.can.flash = Math.max(0, state.can.flash - dt);

    if (state.phase==='thrown' && !state.slippers.some(s=>s.active)){
      state.phase='retrieve'; state.statusMsg='Retrieve your slipper!';
    }

    if (state.phase==='retrieve'){
      let nearest=null, best=1e9;
      for(const s of state.slippers){ const d2v = dist2(p,s); if (d2v < best){ best=d2v; nearest=s; } }
      if (nearest && best <= PICKUP_DIST*PICKUP_DIST && !state.retrieveHasSlipper){
        state.retrieveHasSlipper = true; state.slippers.length = 0;
      }
      if (state.retrieveHasSlipper && p.x <= SAFE_X-4){
        if (state.can.fallen){ state.score += 1; state.round += 1; state.cooldown = 800; }
        state.phase='aim'; state.retrieveHasSlipper=false; state.statusMsg='Aim & Flick'; resetRound();
      }
    }

    const it = state.it;
    if (state.phase!=='over'){
      if (state.phase==='retrieve' && p.x>SAFE_X){
        const dx = p.x - it.x, dy = p.y - it.y; const L = Math.hypot(dx,dy)||1;
        const prevX = it.x, prevY = it.y;
        it.x += (dx/L) * it.speed; it.y += (dy/L) * it.speed;
        const ivx = it.x - prevX, ivy = it.y - prevY;
        if (Math.hypot(ivx,ivy) > 0.05) it.walk += dt*0.02;
        if (dist2(p,it) <= TAG_DIST*TAG_DIST) gameOver();
      } else {
        it.t += dt*0.0012; const t = (Math.sin(it.t)*0.5+0.5);
        const prevX = it.x, prevY = it.y;
        it.x = it.patrolA.x*(1-t) + it.patrolB.x*t;
        it.y = it.patrolA.y*(1-t) + it.patrolB.y*t;
        if (Math.hypot(it.x-prevX, it.y-prevY) > 0.05) it.walk += dt*0.018;
      }
    }

    for (const pu of state.powerups) pu.ttl -= dt;
    state.powerups = state.powerups.filter(pu=>pu.ttl>0);
    for (let i=state.powerups.length-1;i>=0;i--){
      const pu = state.powerups[i];
      if (dist2(state.player,pu) < (PLAYER_R+12)*(PLAYER_R+12)){
        if (pu.type==='double') state.doubleActive=true; else state.windActive=true;
        state.powerups.splice(i,1);
      }
    }

    $score.textContent = `Score: ${state.score}`;
    $round.textContent = `Round: ${state.round}`;
    $status.textContent = `Status: ${state.statusMsg|| (state.phase==='aim'?'Aim & Flick': state.phase)}`;
    if (state.cooldown>0) state.cooldown -= dt;
  }

  function render(dt){
    ctx.clearRect(0,0,W(),H());
    drawField();
    drawPowerups();
    drawCan();

    drawHuman(state.it.x, state.it.y, { scale: 1.9, facing: -1, walk: state.it.walk });
    for(const s of state.slippers) drawSlipper(s);

    const facing = state.phase==='retrieve' ? (state.player.lastX <= state.player.x ? 1 : -1) : 1;
    drawHuman(state.player.x, state.player.y, { scale: 1.9, facing, walk: state.player.walk, carry: state.phase==='retrieve' && state.retrieveHasSlipper });

    if (state.phase==='retrieve' && state.retrieveHasSlipper){
      drawSlipper({x:state.player.x+18,y:state.player.y-12,active:false,rot:0,vx:0,vy:0});
    }

    drawAim();
    drawUI();
    drawFX(dt);
    if (state.cooldown>0){
      const alpha = Math.min(0.25, state.cooldown/800*0.25);
      ctx.fillStyle=`rgba(255,255,255,${alpha})`; ctx.fillRect(0,0,W(),H());
    }
  }

  // Loop
  let last=performance.now();
  function loop(now){
    const dt = now-last; last=now;
    update(dt);
    render(dt);
    requestAnimationFrame(loop);
  }

  function gameOver(){
    state.phase='over';
    $finalStats.textContent = `You scored ${state.score} point${state.score===1?'':'s'} over ${state.round-1} round${state.round-1===1?'':'s'}.`;
    setTimeout(()=>{ document.getElementById('gameover').style.display='flex'; }, 150);
  }

  function restart(){
    document.getElementById('help').style.display='none';
    document.getElementById('gameover').style.display='none';
    if (!streetBG) buildStreetBG();
    state = makeState(); resetRound(); last = performance.now();
  }

  restart(); requestAnimationFrame(loop);
  window.addEventListener('contextmenu', e=> e.preventDefault());
})();
</script>
</body>
</html>
